@immutable
{{#if description }}{{ multilineComment description }}{{/if}}
class {{ className }} extends Equatable {
  {{#if typeName }}
  static final String schemaTypeName = "{{ typeName }}";
  {{/if}}

  // just to make fromObjectType work with unions
  @protected
  {{ className }} get fields => this;
  @protected
  {{ className }}.fromFields({{ className }} other):
    {{#each possibleTypes~}}
    {{inlineFragmentName this}} = other.{{inlineFragmentName this}}{{#unless @last}},{{/unless}}
    {{~/each}};

  static const possibleTypes = const {
    {{#each possibleTypes~}}
    {{this}}{{#unless @last}},
    {{/unless}}
    {{~/each}}
  };

  {{#each possibleTypes~}}
  final {{ this }} {{inlineFragmentName this}};
  {{/each}}

  const {{ className }}({
    {{#each possibleTypes~}}
    this.{{inlineFragmentName this}},
    {{/each}}
  });


  /// The wrapped value. Will be one of the `possibleTypes`
  Object get value => {{#each possibleTypes~}}
    {{inlineFragmentName this}} {{#unless @last}}??{{/unless}}
    {{~/each}};

  @override
  List<Object> get props => [value];
  
  /// Creates a new [{{ className }}] with `value.mergedLeftWith(other.value)`
  ///
  /// If [other].value is not the same type, [other] is returned.
  {{ className }} mergedLeftWith(covariant {{ name }} other) {
    assert(other?.value != null, "$this Cannot be merged with null value from $other");
    {{#each possibleTypes~}}
    if ({{inlineFragmentName this}} != null && other.{{inlineFragmentName this}} != null){
      return {{../className}}({{inlineFragmentName this}}: {{inlineFragmentName this}}.mergedLeftWith(other.{{inlineFragmentName this}}));
    }
    {{/each}}
    // merging cannot be done
    return other;
  }

  /// Alias for [mergedLeftWith]
  {{ className }} operator <<(covariant {{ className }} other) => mergedLeftWith(other);

}
