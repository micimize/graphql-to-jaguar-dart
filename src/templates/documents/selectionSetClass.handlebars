{{#*inline "nullify" ~}}
{{dartName this}}: {{dartName this}} == false ? this.{{dartName this}} : null
{{~/inline}}

@JsonSerializable()
class {{ className }} {{

    classExtends
        baseType=typeName
        mixins=(resolveMixins allFields)
        fragments=fragmentsSpread
        interfaces=interfaces

}} {
  {{#if typeName }}
  static final String schemaTypeName = "{{ typeName }}";
  {{/if}}

  /// The `__typename` meta-field 
  ///
  /// GraphQL supports type name introspection at any point within a query by the meta-field `__typename: String!` ([spec])
  ///
  /// [spec]: https://github.com/graphql/graphql-spec/blob/c7bface58bf6f58cc809f279cba1b6245de914b4/spec/Section%204%20--%20Introspection.md#type-name-introspection)
  @JsonKey(name: r'__typename', required: false, disallowNullValue: true)
  final String {{dartName @root.config.typenameField}};

  {{> selectionSet this excludeDupes='true' }}

  {{~#eachDuplicateBy allFields uniqueField='schemaFieldName'}}
  @JsonKey(name: r'{{name}}', required: {{isRequired}}, disallowNullValue: {{isRequired}})
  {{ resolveType type
      'final'
      ../contextName
      ../contextModels
      isArray
      raw
      name
  }} {{ dartName name }};
  {{/eachDuplicateBy}}
  

  {{#if hasInlineFragments~}}
  {{#each inlineFragments}}
  @JsonKey(ignore: true)
  final {{ concat ../contextName name }} {{ inlineFragmentName name}};
  {{/each}}
  {{~/if}}

  @override
  List<Object> get props => [
    ...super.props,
    {{~#eachDuplicateBy allFields uniqueField='schemaFieldName'}}
    {{ dartName name }},
    {{/eachDuplicateBy~}}
    {{#if hasInlineFragments~}}
    {{#each inlineFragments}}
    {{ inlineFragmentName name}},
    {{/each}}
    {{~/if}}
  ];

  {{className}}({
    this.{{dartName @root.config.typenameField}},
    {{#each inlineFragments~}}
    this.{{ inlineFragmentName name}},
    {{/each}}
    {{#eachUniqueBy allFields uniqueField='schemaFieldName' required='name' excluding='__typename' }}
      {{#if isRequired }}@required {{/if}}
      {{ resolveType type
          'inline'
          (takeFirst contextName ../contextName)
          (takeFirst contextModels ../contextModels)
          isArray
          raw
          ../name
      }} {{dartName name}},
      {{~else~}}
      {{~#each this}}
      this.{{dartName name}},
      {{/each}}
    {{/eachUniqueBy}} {{!-- VV coupled to the same eachUniqueBy in selectionSet --}}
  }): super(
      {{~#eachUniqueBy allFields uniqueField='schemaFieldName'}}
      {{dartName schemaFieldName}}: {{dartName name}},
      {{/eachUniqueBy~}}
    );

  {{ className }}.fromObjectType({{ toPascalCase typeName }} objectType, {
    this.{{dartName @root.config.typenameField}},
    {{#each inlineFragments~}}
    this.{{ inlineFragmentName name}},
    {{/each}}
    {{~#eachDuplicateBy allFields uniqueField='schemaFieldName'}}
    this.{{dartName name}},
    {{/eachDuplicateBy ~}}
  }): super.fromFields(objectType.fields);


  {{className}}.partial({
    this.{{dartName @root.config.typenameField}},
    {{#each inlineFragments~}}
    this.{{ inlineFragmentName name}},
    {{/each}}
    {{#eachUniqueBy allFields uniqueField='schemaFieldName' required='name' excluding='__typename' }}
      {{ resolveType type
          'inline'
          (takeFirst contextName ../contextName)
          (takeFirst contextModels ../contextModels)
          isArray
          raw
          ../name
      }} {{dartName name}},
      {{~else~}}
      {{~#each this}}
      this.{{dartName name}},
      {{/each}}
    {{/eachUniqueBy}} {{!-- VV coupled to the same eachUniqueBy in selectionSet --}}
  }): super(
      {{~#eachUniqueBy allFields uniqueField='schemaFieldName'}}
      {{dartName schemaFieldName}}: {{dartName name}},
      {{/eachUniqueBy~}}
    );

  @protected
  Set<String> get missingRequiredFields {
    Set<String> missingFields = Set();
    {{#each allFields}}
    {{~#if isRequired}}
    if ({{ dartName name }} == null){
      missingFields.add("
      {{~ dartName name ~}}
      {{~#if isAliased}} aliased from {{ dartName schemaFieldName }}
      {{~/if~}}
      ");
    }
    {{/if}}
    {{/each}}
    return missingFields;
  }

  /// Creates a new [{{ className }}] with the given non-null values overridden
  {{ className }} copyWith({
    String {{dartName @root.config.typenameField}},
    {{#each inlineFragments~}}
    {{ concat ../contextName name }} {{ inlineFragmentName name}},
    {{~/each}}
    {{#emptySafeEach allFields required='name' excluding='__typename' }}
      {{ resolveType type
          'inline'
          (takeFirst contextName ../contextName)
          (takeFirst contextModels ../contextModels)
          isArray
          raw
          ../name
      }} {{dartName name}},
    {{/emptySafeEach}}
  }) => {{ className }}(
    {{dartName @root.config.typenameField}}: {{dartName @root.config.typenameField}} ?? this.{{dartName @root.config.typenameField}},
    {{#each inlineFragments~}}
    {{ inlineFragmentName name}}: {{ inlineFragmentName name}} != null ?
      {{#if isArray~}}
      other.{{ inlineFragmentName name}}
      {{~else~}}
      this.{{ inlineFragmentName name}}?.mergedLeftWith({{ inlineFragmentName name}}) ?? {{ inlineFragmentName name}}
      {{~/if}}
      : this.{{ inlineFragmentName name}},
    {{~/each}}
    {{#emptySafeEach allFields required='name' excluding='__typename' }}
      {{ dartName name }}: {{ dartName name }} ?? this.{{ dartName name }},
    {{/emptySafeEach}}
  );

  /// Creates a new [{{ className }}] with the specified fields nullified
  ///
  /// All fields default to `false`, so `field: null` or `field: true` nullifies a field.
  {{ className }} copyWithout({
    bool {{dartName @root.config.typenameField}} = false,
    {{#each inlineFragments~}}
    bool {{ inlineFragmentName name}} = false,
    {{~/each}}
    {{#emptySafeEach allFields required='name' excluding='__typename' }}
    bool {{dartName name}} = false,
    {{/emptySafeEach}}
  }) => {{ className }}(
    {{> nullify @root.config.typenameField }},
    {{#each inlineFragments~}}
    {{> nullify (inlineFragmentName name) }},
    {{~/each}}
    {{#emptySafeEach allFields required='name' excluding='__typename' }}
    {{> nullify name }},
    {{/emptySafeEach}}
  );

  /// Creates a new [{{ className }}] with non-null values from [other] as attribute overrides
  {{ className }} mergedLeftWith(covariant {{ takeFirst selectionSetOf className }} other) {
    assert(other != null, "$this Cannot be merged with null");
    return copyWith(
      {{dartName @root.config.typenameField}}: other.{{dartName @root.config.typenameField}},
      {{#each inlineFragments~}}
      {{ inlineFragmentName name}}: other.{{ inlineFragmentName name}},
      {{~/each}}
      {{#emptySafeEach allFields required='name' excluding='__typename' }}
      {{ dartName name }}: other.{{ dartName name }},
      {{/emptySafeEach}}
    );
  }

  /// Alias for [mergedLeftWith]
  @override
  {{ className }} operator <<(covariant {{ takeFirst selectionSetOf className }} other) => mergedLeftWith(other);

  factory {{className}}.fromJson(Map<String, dynamic> json) =>
     _${{className}}FromJson(json){{#if hasInlineFragments~}}
      .copyWith(
        {{~#each inlineFragments}}
        {{ inlineFragmentName name}}: {{ concat ../contextName name }}.schemaTypeName == json['__typename']
          ? {{ concat ../contextName name }}.fromJson(json)
          : null,
        {{/each}}
      )
      {{~/if}};

  Map<String, dynamic> toJson() {
    Map<String, dynamic> json = _${{className}}ToJson(this);

    {{#if hasInlineFragments~}}
    {{#each inlineFragments}}
    if ({{ inlineFragmentName name}} != null){
        json.addAll({{ inlineFragmentName name}}.toJson());
    }
    {{/each}}
    {{~/if}}

    return json;
  }

  {{#if selectionSetOf}}
  /// Construct a [{{ className }}] from a [{{selectionSetOf}}]
  factory {{ className }}.from({{ selectionSetOf }} source) {
    assert(source != null, "Cannot construct {{ className }} from null");
    return {{ className }}(
      {{dartName @root.config.typenameField}}: source.{{dartName @root.config.typenameField}},
      {{#each inlineFragments~}}
      {{ inlineFragmentName name}}: source.{{ inlineFragmentName name}},
      {{~/each}}
      {{#emptySafeEach allFields required='name' excluding='__typename' }}
      {{ dartName name }}: source.{{ dartName name }},
      {{/emptySafeEach}}
    );
  }
  {{/if}}


}
